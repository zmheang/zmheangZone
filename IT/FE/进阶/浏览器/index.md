# 浏览器
[参考](https://blog.poetries.top/browser-working-principle/)

[TOC]



## 浏览器相关知识

### 一、缓存机制

1. #### 	强缓存

   浏览器直接从本地缓存中获取数据，不与服务器进行交互，它有两种依据：`Expires` 和 `Cache-Control` 可以用来判断是否命中缓存

   1. Expires

      即过期时间，存在于服务器返回的响应头中，即浏览器在这个过期时间之前可以直接冲缓存里面获取数据，无需再次请求

   2. Cache-Control

      在`HTTP1.1`中采用的一个非常关键的字段。我们利用Cache-Control 来控制缓存，一般情况下我们可以设置：

      ```javascript
      Cache-Control:max-age=3600
      ```

      当然还可以配合其他指令一起使用：

      ```
      public： 表示响应可以被客户端和代理服务器缓存；
      private： 表示响应只可以被客户端缓存，而代理服务器不能缓存；
      no-store： 表示不缓存任何响应。
      ```

2. #### 协商缓存

   就是强缓存失效之后，浏览器（携带缓存标识）向服务器发起请求，由服务器（根据缓存标识）决定是否使用本地缓存的过程，主要由两种情况：

   1. `Last-Modified /  If-Modified-Since`

      - 浏览器在第一次访问资源时，服务器返回资源的同时，在响应头中添加了`Last-Modified`，值是这个资源在服务器上的最后修改时间，浏览器接收后就会缓存文件和 header

        ```
        Last-Modified: Fri, 22 Jul 2020 01:47:00 GMT
        ```

      - 当浏览器下一次请求这个资源的时候，浏览器检测到`Last-Modified`这个header， 于是添加`If-Modified-Since`这个header，值就是`Last-Modified`中的值

      - 服务器再次收到这个资源请求，会根据`If-Modified-Since`中的值和服务器中这个资源的最后修改时间进行对比

        如果没有变化，返回304和空的响应体，直接从缓存中度读取资源

        如果`If-Modified-Since` 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200

   2. `Etag / If-None-Match`

      - Etag 是服务器给文件生成的唯一标识，只要里面的内容有改动，这个值就会发生变化，服务器通过响应头把这个值给浏览器
      - 浏览器在下一次向服务器发送请求时，会将上一次返回的Etag值放到请求头中的`If-None-Match`中
      - 服务器只需要比较客户端传来的`If-None-Match`跟自己本地的Etag是否一致即可

3. #### 内核

   每种浏览器都有自己不用的内核，而内核又分为两部分：渲染引擎 和 JS引擎

   - ##### 渲染引擎

     ```
     firefox使用gecko引擎
     
     IE使用Trident引擎，2015年微软推出自己新的浏览器，原名叫斯巴达，后改名edge，使用edge引擎
     
     opera最早使用Presto引擎，后来弃用
     
     chrome\safari\opera使用webkit引擎，13年chrome和opera开始使用Blink引擎
     
     UC使用U3引擎
     
     QQ浏览器和微信内核使用X5引擎，16年开始使用Blink引擎
     ```

   - ##### JS引擎

     ```
     老版本IE使用Jscript引擎，IE9之后使用Chakra引擎，edge浏览器仍然使用Chakra引擎
     
     firefox使用monkey系列引擎
     
     safari使用的SquirrelFish系列引擎
     
     Opera使用Carakan引擎
     
     chrome使用V8引擎。nodeJs其实就是封装了V8引擎
     ```

     ##### 为什么会有这么多的不同？

     HTML，CSS，JS这些只是一种规范，告诉浏览器遇到这种标签怎么渲染，遇到这种样式怎么渲染，遇到这种脚本怎么执行，但是具体怎么执行的时浏览器内部的事情，对于我们程序员来说是不必要知道的，对于为什么有这么多不同种类的浏览器，因为厂家不同啊，你想成立一家浏览器公司，就必须有自己的浏览器，而且还不能使用别家浏览器的代码，只能自己实现，所以实现的方法就各不相同，所以这样也就会有自己侧重点，比如这家渲染快，这家脚本执行优化的更好等等

4. #### chrome架构

   - 进程与线程

   - 单进程浏览器

   - ##### 多进程浏览器

     最新的Chrome浏览器包括：1个浏览器主进程，1个GPU进程，1个网络进程，多个渲染进程和多个插件

     - ###### 浏览器进程

       主要负责界面的显示、用户交互、子进程管理，同时提供存储等功能

     - ###### 渲染进程

       核心任务是将HTML,CSS和JavaScript转换为用户可以与之交互的网页，处于安全考虑，渲染进程都是运行在沙箱模式

       通常情况下打开一个新页面都会使用三度的渲染进程，但是如果从A页面打开B页面，且A和B 都属于同一个站点的话，那么B页面就会复用A页面的渲染进程

     - ###### GPU进程

       负责页面的UI绘制

     - ###### 网络进程

       主要负责网络资源的加载

     - ###### 插件进程

       主要负责插件的运行

   - 面向服务的浏览器

### 二、本地存储

1. #### Cookie

   `HTTP Cookie`是浏览器第一次发请求到服务器时，饭后服务器返回给浏览器并保存在本地的一小块数据，然后在浏览器下次再次向同一域名发请求时都会携带的Cookie。服务器拿到Cookie进行解析，便能获取客户端的状态

   缺点：

   - 容量小：不能超过4kb
   - 安全性低
   - 影响性能：cookie紧跟域名，只要是相同域名下，就会带上Cookie，不管域名下的地址是否需要Cookie信息

2. #### LocalStorage

   - 只存在客户端
   - 容量大：5M
   - 接口封装
   - 影响性能：同Cookie

3. #### sessionStorage

   - 只存在客户端
   - 容量大：5M
   - 接口封装
   - 会话级别

4. #### IndexDB

   浏览器提供的本地数据库



## 从输入URL到页面加载的过程

### 1.在浏览器中输入URL

---接下来还有一步：同一域名下最多只能建立6个TCP连接，剩余的进入排队等待状态

### 2.先检查强缓存，如果命中直接使用，否则进入下一步

### 3.DNS域名解析系统对输入的网址进行解析

#### 		浏览器缓存 -> 本地缓存 -> 系统hosts -> 路由器 -> 本地域名服务器 -> 根服务器 -> 顶级服务器 

### 4.建立TCP连接

#### 		三次握手四次挥手

### 5.客户端发送http请求

​		正常完成一次请求，连接便会断开，但是当请求头中加入了这样的信息时，该连接将一直保持打开状态

```
	Connection:Keep-Alive 
```

### 6.服务端响应请求

​		重定向：当响应码位301时，响应头中会有一个属性`Location`，接下来浏览器就会获取该字段中的地址，并使用该地址进行重新导航

### 7.浏览器解析响应请求，并渲染页面

1. 渲染进程将HTML内容转化为DOM树
2. 渲染进程将CSS转化为styleSgeets
3. 创建布局树，并计算元素的布局信息
4. 对布局进行分层，并生成分层树
5. 为每个图层生成绘制列表，并将其提交到合成线程
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图
7. 合成线程发送绘制图块命令DrawQuad给浏览器进程
8. 浏览器根据DrawQuad消息生成页面，并显示到显示器上 



## JavaScript执行机制

### 变量提升/ 函数提升

浏览器运行一段JS代码，会先编译，再运行

- #### 编译阶段

  通过编译阶段，会生成两部分内容：执行上下文和可执行代码

  代码一行行执行，遇到变量声明或者函数声明就会在执行上下文中创建对应的属性并初始化值，最后将声明以外的代码编译成字节码作为可执行代码

- #### 执行阶段

  运行可执行代码，一行行执行

### 调用栈

- 每调用一个函数，JavaScript引擎会为其创建执行上下文，并把该执行上下文压入调用栈，期间再次调用其他函数同样会创建执行上下文，并压入调用栈，在函数执行结束后，将其执行上下文从调用栈中弹出

### 块级作用域



### 作用域链和闭包

​		在JavaScript中，根据词法作用域的规则，内部函数总是可以访问外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，及时该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合成为闭包

### this













































