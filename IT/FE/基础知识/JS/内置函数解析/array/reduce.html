<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

</body>
<script>
  console.log('test-reduce')
  // array.reduce()
  // 1. 参数initialValue： 若没有的话会使用数组中的第一个值，这样遍历会少一次
  // 2.


  const array1 = [1, 2, 3, 4];
  const reducer = (acc, cur, idx, src) => {
    console.log(acc)      // 累加值
    console.log(cur)      // 当前值
    console.log(idx)      // 当前索引
    console.log(src)      // 源数组
    return acc + cur
  };
  // console.log(array1.reduce(reducer));
  // console.log(array1.reduce(reducer, 5));


  const maxCallback = ( acc, cur ) => {
    // console.log(acc)
    // console.log(cur)
    return Math.max( acc.x, cur.x )
  };
  const maxCallback2 = ( max, cur ) => {
    // console.log(max)
    // console.log(cur)
    return Math.max( max, cur )
  };
  // reduce() 没有初始值
  // console.log([ { x: 2 }, { x: 22 }, { x: 42 } ].reduce( maxCallback2 ))
  // console.log([ { x: 2 }, { x: 22 }            ].reduce( maxCallback ))
  // console.log([ { x: 2 }                       ].reduce( maxCallback ))


  // 二维数组转一维
  let arr = [
    [1, 2, 3, 4],
    [5, 6, 7],
  ]
  const flattened = (acc, cur) => acc.concat(cur)
  // console.log(arr.reduce(flattened, []))


  // 数组中每个元素出现的次数
  let names = ['Alice', 'Bob', 'lily', 'zmheang', 'Tiff', 'lily', 'Bruce', 'Alice'];
  const countedNames = (acc, cur) => {
    if(acc.hasOwnProperty(cur)) {
      acc[cur] ++
    }else {
      acc[cur] = 1
    }
    return acc
  }
  // console.log(names.reduce(countedNames, {}))


  // 数组去重
  let list = [1, 2, 3, 4, 2, 3, 5, 6, 7, 3, 4, 6, 7, 9, 0, 4, 5, 3]
  const Deduplication = (acc, cur) => {
    if(acc.length == 0 || acc[acc.length - 1] !== cur) {
      acc.push(cur)
    }
    return acc
  }
  console.log(list.sort().reduce(Deduplication, []))







  // test:
  // console.log(Math.max(NaN, 42))

</script>
</html>
